Лабораторная работа №1. «Автоматическое распараллеливание программ»
4.1 Порядок выполнения работы
1. На компьютере с многоядерным процессором установить ОС Linux
и компилятор GCC версии не ниже 4.7.2. При невозможности установить Linux или отсутствии компьютера с многоядерным процессором можно выполнять лабораторную работу на виртуальной машине.
2. На языке Cи написать консольную программу lab1.c, решающую
задачу, указанную в п.IV (см. ниже). В программе нельзя использовать библиотечные функции сортировки, выполнения матричных
операций и расчёта статистических величин. В программе нельзя
использовать библиотечные функции, отсутствующие в стандартных заголовочных файлах stdio.h, stdlib.h, math.h, sys/time.h. Задача
должна решаться 50 раз с разными начальными значениями генератора случайных чисел (ГСЧ). Структура программы примерно
следующая:

1 #include <stdio.h>
2 #include <stdlib.h>
3 #include <sys/time.h>
4 int main(int argc, char* argv[])
5 {
6 int i, N;
7 struct timeval T1, T2;
8 long delta_ms;
9 N = atoi(argv[1]); /* N равен первому параметру командной строки */
10 gettimeofday(&T1, NULL); /* запомнить текущее время T1 */
11 for (i=0; i<50; i++) /* 50 экспериментов */
12 {
13 srand(i); /* инициализировать начальное значение ГСЧ */
14 /* Заполнить массив исходных данных размером N */
15 /* Решить поставленную задачу, заполнить массив с результатами
*/
16 /* Отсортировать массив с результатами указанным методом */
17 }
18 gettimeofday(&T2, NULL); /* запомнить текущее время T2 */
19 delta_ms = 1000*(T2.tv_sec - T1.tv_sec) + (T2.tv_usec - T1.tv_usec)
/1000;
20 printf("\nN=%d. Milliseconds passed: %ld\n", N, delta_ms); /* T2 -
T1 */
21 return 0;
22 }
3. Скомпилировать написанную программу без использования авто75
матического распараллеливания с помощью следующей команды:
/home/user/gcc -O3 -Wall -Werror -o lab1-seq lab1.c
4. Скомпилировать написанную программу, используя встроенное в
gcc средство автоматического распараллеливания Graphite с помощью следующей команды “/home/user/gcc -O3 -Wall -Werror -floopparallelize-all -ftree-parallelize-loops=K lab1.c -o lab1-par-K” (переменной K поочерёдно присвоить хотя бы 4 различных целых значений, выбор обосновать).
5. В результате получится одна нераспараллеленная программа и четыре или более распараллеленных.
6. Закрыть все работающие в операционной системе прикладные программы (включая Winamp, uTorrent, браузеры и Skype), чтобы они
не влияли на результаты последующих экспериментов.
7. Запускать файл lab1-seq из командной строки, увеличивая значения
N до значения N1, при котором время выполнения превысит 0.01
с. Подобным образом найти значение N=N2, при котором время
выполнения превысит 2 с.
8. Используя найденные значения N1 и N2, выполнить следующие
эксперименты (для автоматизации проведения экспериментов рекомендуется написать скрипт):
 запускать lab1-seq для значений
N = N1, N1 + ∆, N1 + 2∆, N1 + 3∆, . . . , N2 и записывать получающиеся значения времени delta_ms(N) в
функцию seq(N);
 запускать lab1-par-K для значений
N = N1, N1 + ∆, N1 + 2∆, N1 + 3∆, . . . , N2 и записывать получающиеся значения времени delta_ms(N) в
функцию par − K(N);
 значение ∆ выбрать так: ∆ = (N2 − N1)/10.
9. Написать отчёт о проделанной работе.
10. Подготовиться к устным вопросам на защите.
11. Найти вычислительную сложность алгоритма до и после распараллеливания, сравнить полученные результаты.
76
12. Необязательное задание №1 (для получения оценки «четыре» и «пять»). Провести аналогичные описанным эксперименты, используя вместо gcc компилятор Solaris Studio
(или любой другой на своё усмотрение). При компиляции следует использовать следующие опции для автоматического распараллеливания: «solarisstudio -cc -O3 -
xautopar -xloopinfo lab1.c».

1. Этап Generate. Сформировать массив М1 размерностью N, заполнив его с помощью функции rand_r (нельзя использовать rand) случайными вещественными числами, имеющими равномерный закон
распределения в диапазоне от 1 до A (включительно). Аналогично
сформировать массив М2 размерностью N/2 со случайными вещественными числами в диапазоне от А до 10*А.
2. Этап Map. В массиве М1 к каждому элементу применить операцию из таблицы:
78
Номер
варианта
Операция
1
Гиперболический синус с последующим
возведением в квадрат
2
Гиперболический косинус с последующим
увеличением на 1
3
Гиперболический тангенс с последующим
уменьшением на 1
4
Гиперболический котангенс
корня числа
5
Деление на Пи с последующим возведением
в третью степень
6
Кубический корень после деления
на число e
7
Экспонента квадратного корня
(т.е. M1[i] = exp(sqrt(M1[i])))
Затем в массиве М2 каждый элемент поочерёдно сложить с предыдущим (для этого вам понадобится копия массива М2, из которого
нужно будет брать операнды), а к результату сложения применить
операцию из таблицы (считать, что для начального элемента массива предыдущий элемент равен нулю):
Номер
варианта
Операция
1 Модуль синуса (т.е. M2[i] = |sin(M2[i] + M2[i-1])|)
2 Модуль косинуса
3 Модуль тангенса
4 Модуль котангенса
5 Натуральный логарифм модуля тангенса
6 Десятичный логарифм, возведенный в степень e
7 Кубический корень после умножения на число Пи
8 Квадратный корень после умножения на e
3. Этап Merge. В массивах М1 и М2 ко всем элементами с одинаковыми индексами попарно применить операцию из таблицы (результат записать в М2):
79
Номер
варианта
Операция
1 Возведение в степень (т.е. M2[i] = M1[i]^M2[i])
2 Деление (т.е. M2[i] = M1[i]/M2[i])
3 Умножение
4 Выбор большего (т.е. M2[i] = max(M1[i],M2[i])))
5 Выбор меньшего
6 Модуль разности
4. Этап Sort. Полученный массив необходимо отсортировать методом, указанным в таблице (для этого нельзя использовать библиотечные функции; можно взять реализацию в виде свободно доступного исходного кода):
Номер
варианта
Операция
1 Сортировка выбором (Selection sort).
2 Сортировка расчёской (Comb sort).
3
Пирамидальная сортировка (сортировка кучи,
Heapsort).
4 Глупая сортировка (Stupid sort).
5 Гномья сортировка (Gnome sort).
6 Сортировка вставками (Insertion sort).
7 Сортировка выбором (Selection sort).
5. Этап Reduce. Рассчитать сумму синусов тех элементов массива
М2, которые при делении на минимальный ненулевой элемент массива М2 дают чётное число (при определении чётности учитывать только целую часть числа). Результатом работы программы по
окончании пятого этапа должно стать одно число X, которое следует использовать для верификации программы после внесения в
неё изменений (например, до и после распараллеливания итоговое
число X не должно измениться в пределах погрешности). Значение
числа X следует привести в отчёте для различных значений N.
